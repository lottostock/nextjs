"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var FirestoreStorage_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FirestoreTransaction = exports.FirestoreStorage = exports.StorageEventType = void 0;
const inversify_1 = require("inversify");
const admin = require("firebase-admin");
var DocumentReference = admin.firestore.DocumentReference;
const ff_utils_1 = require("ff-utils");
const stream_1 = require("stream");
const firestore_storage_core_1 = require("firestore-storage-core");
const common_1 = require("@nestjs/common");
const events_1 = require("events");
var StorageEventType;
(function (StorageEventType) {
    StorageEventType["Read"] = "read";
    StorageEventType["Write"] = "write";
    StorageEventType["Delete"] = "delete";
})(StorageEventType = exports.StorageEventType || (exports.StorageEventType = {}));
inversify_1.decorate(inversify_1.injectable(), events_1.EventEmitter);
let FirestoreStorage = FirestoreStorage_1 = class FirestoreStorage extends events_1.EventEmitter {
    constructor(firestore) {
        super();
        this.firestore = firestore;
    }
    static clone(data) {
        const clone = Object.assign({}, data);
        const id = data.id;
        delete clone.id;
        delete clone.createdAt;
        delete clone.updatedAt;
        delete clone._rawPath;
        return {
            id: id,
            data: clone
        };
    }
    static format(snapshot) {
        if (!snapshot.exists) {
            return null;
        }
        return Object.assign({
            id: snapshot.id,
            createdAt: new Date(snapshot.createTime.toMillis()),
            updatedAt: new Date(snapshot.updateTime.toMillis()),
            _rawPath: snapshot.ref.path
        }, snapshot.data());
    }
    static getPath(collection, id) {
        return `${collection}/${id}`;
    }
    findById(collection, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = FirestoreStorage_1.getPath(collection, id);
            const snapshot = yield this.firestore.doc(path).get();
            this.emitRead(collection, 1);
            return FirestoreStorage_1.format(snapshot);
        });
    }
    find(collection, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            // Emits event via query
            const result = yield this.query(collection, (qb) => {
                return cb(qb).limit(1);
            });
            return result[0] || null;
        });
    }
    save(collection, data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emitWrite(collection, 1);
            this.emitRead(collection, 1);
            const model = FirestoreStorage_1.clone(data);
            if (!model.id) {
                return this.add(collection, model.data);
            }
            const path = FirestoreStorage_1.getPath(collection, model.id);
            const docRef = yield this.firestore.doc(path);
            yield docRef.set(model.data, {
                merge: !(options && options.avoidMerge)
            });
            const doc = yield docRef.get();
            return FirestoreStorage_1.format(doc);
        });
    }
    update(collection, data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.emitWrite(collection, 1);
            const clone = FirestoreStorage_1.clone(data);
            if (!clone.id) {
                return this.add(collection, clone.data);
            }
            const path = FirestoreStorage_1.getPath(collection, clone.id);
            const docRef = yield this.firestore.doc(path);
            const shouldMerge = !(options && options.avoidMerge);
            yield docRef.update(clone.data, {
                merge: shouldMerge
            });
            const model = yield docRef.get();
            return FirestoreStorage_1.format(model);
        });
    }
    query(collection, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const qb = this.firestore.collection(collection);
            return this.executeQuery(collection, cb ? cb(qb) : qb);
        });
    }
    groupQuery(collectionId, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const qb = this.firestore.collectionGroup(collectionId);
            return this.executeQuery(collectionId, cb ? cb(qb) : qb);
        });
    }
    executeQuery(collection, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield query.get();
            if (result.empty) {
                return [];
            }
            let count = 0;
            const data = result.docs.map((document) => {
                const data = FirestoreStorage_1.format(document);
                if (data) {
                    count++;
                }
                return data;
            });
            this.emitRead(collection, count);
            return data;
        });
    }
    stream(collection, cb, options) {
        const qb = this.firestore.collection(collection);
        const query = cb ? cb(qb) : qb;
        const opts = Object.assign({
            size: 100
        }, options || {});
        class Stream extends stream_1.Readable {
            constructor(size) {
                super({
                    objectMode: true,
                    highWaterMark: size
                });
                this.offset = 0;
            }
            _read(size) {
                query
                    .offset(this.offset)
                    .limit(size)
                    .get()
                    .then((result) => {
                    for (const doc of result.docs) {
                        const data = FirestoreStorage_1.format(doc);
                        this.push(data);
                    }
                    this.offset += result.size;
                    if (result.size < size) {
                        this.push(null);
                    }
                });
            }
        }
        return new Stream(opts.size);
    }
    batchGet(collection, ids) {
        return __awaiter(this, void 0, void 0, function* () {
            if (ids.length === 0) {
                return [];
            }
            const docRefs = ids.map((id) => {
                return this.firestore.collection(collection).doc(id);
            });
            const restDocRefs = docRefs.slice(1);
            const result = yield this.firestore.getAll(docRefs[0], ...restDocRefs);
            let count = 0;
            const data = result.map((document) => {
                const data = FirestoreStorage_1.format(document);
                if (data) {
                    count++;
                }
                return data;
            });
            this.emitRead(collection, count);
            return data;
        });
    }
    transaction(updateFunction, transactionOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.firestore.runTransaction((transaction) => {
                const trx = new FirestoreTransaction(this.firestore, transaction);
                return updateFunction(trx);
            }, transactionOptions);
        });
    }
    delete(collection, id) {
        return __awaiter(this, void 0, void 0, function* () {
            const qb = this.firestore.collection(collection);
            yield qb.doc(id).delete();
            this.emit(StorageEventType.Delete, {
                type: StorageEventType.Delete,
                collection: collection,
                count: 1
            });
        });
    }
    clear(collection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (collection) {
                return this.deleteCollection(collection, 10);
            }
        });
    }
    generateId() {
        return this.firestore.collection('non-existing').doc().id;
    }
    export(rootDoc, options, collectionNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = Object.assign(Object.assign({}, FirestoreStorage_1.EXPORT_OPTIONS), (options || {}));
            console.log(`Exporting ${opts.parallelCollections} collections in parallel and ${opts.parallelDocuments} documents in parallel`);
            const storage = new firestore_storage_core_1.MemoryStorage();
            let root;
            if (rootDoc) {
                root = yield this.firestore.doc(rootDoc);
                const snapshot = yield root.get();
                const data = FirestoreStorage_1.format(snapshot);
                if (data) {
                    yield storage.save(root.parent.path, data);
                }
            }
            else {
                root = this.firestore;
            }
            yield this.exportDocument(storage, root, opts, collectionNames);
            return storage.data.toJson();
        });
    }
    import(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = new firestore_storage_core_1.MemoryStorage();
            yield storage.import(data);
            const collectionNames = Object.keys(storage.data.collections);
            for (const collectionName of collectionNames) {
                yield this.importCollection(collectionName, storage.data.collections[collectionName]);
            }
        });
    }
    importDocument(collectionPath, id, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.save(collectionPath, Object.assign(Object.assign({}, doc.data), { id: id }));
            const collectionNames = Object.keys(doc.collections);
            for (const collectionName of collectionNames) {
                const collection = doc.collections[collectionName];
                yield this.importCollection(`${collectionPath}/${id}/${collectionName}`, collection);
            }
        });
    }
    importCollection(path, collection) {
        return __awaiter(this, void 0, void 0, function* () {
            const docIds = Object.keys(collection.documents);
            for (const docId of docIds) {
                const doc = collection.documents[docId];
                yield this.importDocument(path, docId, doc);
            }
        });
    }
    exportDocument(storage, root, opts, collectionNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const docStart = Date.now();
            const collections = yield root.listCollections();
            const exportColl = (coll) => __awaiter(this, void 0, void 0, function* () {
                const collStart = Date.now();
                const query = yield coll.get();
                const name = coll.path.substring(coll.path.lastIndexOf('/') + 1);
                if (collectionNames && !collectionNames.includes(name)) {
                    console.debug('Skipping', name);
                    return;
                }
                yield ff_utils_1.processPromisesParallelWithRetries(query.docs, opts.parallelDocuments, opts.tries, (doc) => __awaiter(this, void 0, void 0, function* () {
                    yield storage.save(coll.path, FirestoreStorage_1.format(doc));
                    yield this.exportDocument(storage, doc.ref, opts, collectionNames);
                }));
                console.log('Exported', coll.path, 'in', time(Date.now() - collStart));
            });
            yield ff_utils_1.processPromisesParallelWithRetries(collections, opts.parallelCollections, opts.tries, (coll) => __awaiter(this, void 0, void 0, function* () {
                yield exportColl(coll);
            }));
            let path = 'database';
            if (root instanceof DocumentReference) {
                path = root.path;
            }
            console.log('Exported', path, 'in', time(Date.now() - docStart));
        });
    }
    add(collection, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.firestore.collection(collection).add(data);
            const model = yield result.get();
            return FirestoreStorage_1.format(model);
        });
    }
    deleteCollection(collectionPath, batchSize) {
        const collectionRef = this.firestore.collection(collectionPath);
        const query = collectionRef.orderBy('__name__').limit(batchSize);
        return new Promise((resolve, reject) => {
            this.deleteQueryBatch(query, batchSize, resolve, reject);
        });
    }
    deleteQueryBatch(query, batchSize, resolve, reject) {
        query.get()
            .then((snapshot) => {
            // When there are no documents left, we are done
            if (snapshot.size == 0) {
                return 0;
            }
            // Delete documents in a batch
            const batch = this.firestore.batch();
            snapshot.docs.forEach((doc) => {
                batch.delete(doc.ref);
            });
            return batch.commit().then(() => {
                return snapshot.size;
            });
        }).then((numDeleted) => {
            if (numDeleted === 0) {
                resolve();
                return;
            }
            // Recurse on the next process tick, to avoid
            // exploding the stack.
            process.nextTick(() => {
                this.deleteQueryBatch(query, batchSize, resolve, reject);
            });
        })
            .catch(reject);
    }
    emitRead(collection, count) {
        return this.emit(StorageEventType.Read, { type: StorageEventType.Read, collection: collection, count: count });
    }
    emitWrite(collection, count) {
        return this.emit(StorageEventType.Write, { type: StorageEventType.Write, collection: collection, count: count });
    }
};
FirestoreStorage.EXPORT_OPTIONS = {
    parallelCollections: 20,
    parallelDocuments: 500,
    tries: 3
};
FirestoreStorage = FirestoreStorage_1 = __decorate([
    inversify_1.injectable(),
    common_1.Injectable(),
    __param(0, inversify_1.inject(firestore_storage_core_1.FirestoreInstance)), __param(0, common_1.Inject(firestore_storage_core_1.FirestoreInstance)),
    __metadata("design:paramtypes", [admin.firestore.Firestore])
], FirestoreStorage);
exports.FirestoreStorage = FirestoreStorage;
class FirestoreTransaction {
    constructor(firestore, transaction) {
        this.firestore = firestore;
        this.transaction = transaction;
    }
    query(collectionPath, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            //this.transaction.get()
            const q = this.firestore.collection(collectionPath);
            const result = yield this.transaction.get(cb(q));
            if (result.empty) {
                return [];
            }
            return result.docs.map((document) => {
                return FirestoreStorage.format(document);
            });
        });
    }
    get(collectionPath, docId) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = this.firestore.collection(collectionPath).doc(docId);
            const data = yield this.transaction.get(doc);
            if (data.exists) {
                return FirestoreStorage.format(data);
            }
            return null;
        });
    }
    create(collectionPath, data) {
        const model = FirestoreStorage.clone(data);
        const doc = this.firestore.collection(collectionPath).doc();
        this.transaction.create(doc, model.data);
        return this;
    }
    ;
    set(collectionPath, data) {
        const model = FirestoreStorage.clone(data);
        //model.id can be null
        const doc = this.firestore.collection(collectionPath).doc(model.id);
        this.transaction.set(doc, model.data, {
            merge: true
        });
        return this;
    }
    setAvoidMerge(collectionPath, data) {
        const model = FirestoreStorage.clone(data);
        //model.id can be null
        const doc = this.firestore.collection(collectionPath).doc(model.id);
        this.transaction.set(doc, model.data, {
            merge: false
        });
        return this;
    }
    update(collectionPath, data) {
        const model = FirestoreStorage.clone(data);
        const doc = this.firestore.collection(collectionPath).doc(model.id);
        this.transaction.update(doc, model.data);
        return this;
    }
    delete(collectionPath, docId) {
        const doc = this.firestore.collection(collectionPath).doc(docId);
        this.transaction.delete(doc);
        return this;
    }
}
exports.FirestoreTransaction = FirestoreTransaction;
function time(ms) {
    if (ms < 1000) {
        return `${ms}ms`;
    }
    const seconds = Math.round(ms / 10) / 100;
    return `${seconds}s`;
}
//# sourceMappingURL=firestore_storage.js.map