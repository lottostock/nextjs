"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RepositoryTransaction = exports.BaseRepository = void 0;
require("reflect-metadata");
const inversify_1 = require("inversify");
const firestore_storage_core_1 = require("firestore-storage-core");
const common_1 = require("@nestjs/common");
let BaseRepository = class BaseRepository {
    constructor(storage, errorFactory) {
        this.storage = storage;
        this.errorFactory = errorFactory;
    }
    findById(...ids) {
        const docId = ids.pop();
        return this.storage.findById(this.getStringCollectionPath(...ids), docId);
    }
    find(attributes, ...ids) {
        return this.storage.find(this.getStringCollectionPath(...ids), (qb) => {
            return this.mapToWhereClause(qb, attributes);
        });
    }
    get(attributes, ...ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.find(attributes, ...ids);
            if (doc) {
                return doc;
            }
            throw this.createError(attributes, ids);
        });
    }
    getById(...ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield this.findById(...ids);
            if (doc) {
                return doc;
            }
            throw this.createError({ id: ids.pop() }, ids);
        });
    }
    list(attributes, ...ids) {
        return this.query((qb) => {
            return this.mapToWhereClause(qb, attributes);
        }, ...ids);
    }
    mapToWhereClause(query, attributes) {
        if (!attributes) {
            return query;
        }
        return Object.keys(attributes)
            .reduce((query, key) => {
            return query.where(key, '==', attributes[key]);
        }, query);
    }
    query(cb, ...ids) {
        return this.storage.query(this.getStringCollectionPath(...ids), cb);
    }
    groupQuery(cb) {
        let collectionId = this.getCollectionId();
        return this.storage.groupQuery(collectionId, cb);
    }
    getCollectionId() {
        try {
            const path = this.getCollectionPath();
            if (path instanceof Function) {
                return path.collectionGroup;
            }
        }
        catch (err) { }
        throw new Error('Unable to get collection id, getCollectionPath() must return a PathFunction');
    }
    stream(cb, optionsOrId, ...ids) {
        const pathIds = ids || [];
        if (typeof optionsOrId === 'string') {
            pathIds.unshift(optionsOrId);
            optionsOrId = null;
        }
        return this.storage.stream(this.getStringCollectionPath(...pathIds), cb, optionsOrId);
    }
    /**@deprecated Has been replaced with findAll() */
    batchGet(documentIds, ...ids) {
        return this.storage.batchGet(this.getStringCollectionPath(...ids), documentIds);
    }
    /**@deprecated Will be removed in the future.*/
    batchGetNoNulls(documentIds, ...ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const docs = yield this.findAll(documentIds, ...ids);
            return docs.filter(d => d);
        });
    }
    findAll(documentIds, ...ids) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.storage.batchGet(this.getStringCollectionPath(...ids), documentIds);
        });
    }
    getAll(documentIds, ...ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const all = yield this.findAll(documentIds, ...ids);
            for (const id of documentIds) {
                const doc = all.find(d => (d === null || d === void 0 ? void 0 : d.id) === id);
                if (!doc) {
                    throw this.createError({ id: id }, ids);
                }
            }
            return all;
        });
    }
    save(data, ...ids) {
        return this.storage.save(this.getStringCollectionPath(...ids), data);
    }
    write(data, ...ids) {
        return this.storage.save(this.getStringCollectionPath(...ids), data, { avoidMerge: true });
    }
    clear(...ids) {
        return this.storage.clear(this.getStringCollectionPath(...ids));
    }
    delete(...ids) {
        const docId = ids.pop();
        return this.storage.delete(this.getStringCollectionPath(...ids), docId);
    }
    transaction(updateFunction, ...ids) {
        return this.storage.transaction((trx) => {
            return updateFunction(new RepositoryTransaction(this.getStringCollectionPath(...ids), trx));
        });
    }
    generateId() {
        return this.storage.generateId();
    }
    getStringCollectionPath(...docIds) {
        const path = this.getCollectionPath(...docIds);
        if (typeof path === 'string') {
            return path;
        }
        return path(...docIds);
    }
    createError(attributes, ids) {
        const id = attributes.id ? ` (${attributes.id})` : '';
        return this.errorFactory(`Unable to get document${id} from ${this.getStringCollectionPath(...ids)}`);
    }
};
BaseRepository = __decorate([
    inversify_1.injectable(),
    common_1.Injectable(),
    __param(0, inversify_1.inject(firestore_storage_core_1.StorageDriver)), __param(0, common_1.Inject(firestore_storage_core_1.StorageDriver)),
    __param(1, inversify_1.inject(firestore_storage_core_1.ErrorFactory)), __param(1, common_1.Inject(firestore_storage_core_1.ErrorFactory)),
    __metadata("design:paramtypes", [Object, Function])
], BaseRepository);
exports.BaseRepository = BaseRepository;
class RepositoryTransaction {
    constructor(collectionPath, trx) {
        this.collectionPath = collectionPath;
        this.trx = trx;
    }
    create(data) {
        return this.trx.create(this.collectionPath, data);
    }
    delete(docId) {
        return this.trx.delete(this.collectionPath, docId);
    }
    get(docId) {
        return this.trx.get(this.collectionPath, docId);
    }
    query(cb) {
        return this.trx.query(this.collectionPath, cb);
    }
    set(data) {
        return this.trx.set(this.collectionPath, data);
    }
    setAvoidMerge(data) {
        return this.trx.setAvoidMerge(this.collectionPath, data);
    }
    update(data) {
        return this.trx.update(this.collectionPath, data);
    }
}
exports.RepositoryTransaction = RepositoryTransaction;
//# sourceMappingURL=base_repository.js.map